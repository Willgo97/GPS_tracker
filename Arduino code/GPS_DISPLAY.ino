#include <U8glib.h>
#include <NMEAGPS.h>
#include <GPSport.h>
#include "readVCC.h"

U8GLIB_SSD1306_128X32 u8g(U8G_I2C_OPT_NONE);
//------------------------------------------------------------------------------------------------
//  Gps variables
static NMEAGPS  gps;  // This parses the GPS characters
static gps_fix  fix;  // This holds the latest GPS fix

//  holds all the gps data
float max_speed = 0, avg_speed = 0;
float max_distance = 0;

int max_height = 0, min_height = 0, avg_height = 0;
int sat_count = 0;
int battery_lvl = 0;
int count = 0;

bool prev_max_speed = false;
bool prev_max_height = false;
bool prev_min_height = false;
bool prev_max_distance = false;

// The home location, in degrees * 10,000,000
long latitude = 0L, longitude = 0L;
//------------------------------------------------------------------------------------------------
//  The bitmap of the whole screen
#define u8g_XMB_width 128
#define u8g_XMB_height 32
const unsigned char u8g_XMB_bits[] U8G_PROGMEM = {
  0x00, 0x80, 0x21, 0xe1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x12, 0x19, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
  0x0c, 0x48, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x08, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x05, 
  0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x20, 0x84, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x31, 0x49, 0x02, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x20, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x0e, 0xf9, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1f, 0xe1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x20, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x18, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, 0x49, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x31, 
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x20, 0x45, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, 0x49, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x0c, 0x00, 0x00, 0x00, 0x00, 
  0x01, 0x00, 0x10, 0xf8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x02, 0x6d, 
  0xdb, 0xb6, 0x6d, 0xdb, 0xb6, 0x6d, 0xbb, 0x6d, 0xdb, 0xb6, 0x6d, 0xdb, 0x78, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x88, 0x0f, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc1, 0x1f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x06, 0x00, 0x00, 0x00, 0x00, 0x07, 0xea, 0x3f, 0x11, 0x01, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x20, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x20, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x20, 0xfd, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xa0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa2, 0x2d, 0x09, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa9, 0x2d, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 
  0x00, 0x00, 0x00, 0x00, 0x80, 0xa0, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x78, 0xe8, 0x3f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
  0x00, 0x00
};

//  The battery bar
#define u8g_bat_width 20
#define u8g_bat_height 7
const unsigned char u8g_bat_bits[] U8G_PROGMEM = {
  0xff, 0xff, 0x0f, 0xff, 0xff, 0x0f, 0xff, 0xff, 0x0f, 0xff, 0xff, 0x0f, 0xff, 0xff, 0x0f, 0xff, 0xff, 0x0f, 0xff, 0xff, 0x0f
};
//------------------------------------------------------------------------------------------------
void get_battery()
{ //  Calculates the battery voltage, and calculates the battery bar offset accordingly.
  int bat_voltage = (analogRead(A0) * (5.00 / 1023.00)); //read the A0 pin value
  bat_voltage < 3.5 ? bat_voltage = 3.5 : NULL;
  bat_voltage > 4.2 ? bat_voltage = 4.2 : NULL;
  
  //  convert sensorValue to voltage and directly to percent.
  float bat_percentage = map((bat_voltage * (5.00 / 1023.00) * 2), 3.5, 4.2, 0, 100);
  battery_lvl = ( 0.0 - (20.0 - 20.0 / 100.0 * bat_percentage) );
}
//------------------------------------------------------------------------------------------------
void check_button()
{ //  checks if the user pressed the button.
  

}
//------------------------------------------------------------------------------------------------
void calc_data()
{ //  Calculates stuff like max, min and average speed, altitude and distance.
  check_button();
  count++;

  avg_speed = ( (avg_speed * count + fix.speed_kph()) / (count + 1));
  avg_height = ( (avg_height * count + fix.alt.whole) / (count + 1));
  sat_count = fix.satellites;

  NeoGPS::Location_t base( latitude, longitude ); // The homepoint

  if ( fix.speed_kph() > max_speed ) {
    prev_max_speed == true ? max_speed = fix.speed_kph() : prev_max_speed = true;
  } else {
    prev_max_speed = false;
  }

  if ( latitude != 0 && longitude != 0 && fix.location.DistanceKm( base ) * 1000 > max_distance ) {
    prev_max_distance == true ? max_distance = fix.location.DistanceKm( base ) * 1000 : prev_max_distance = true;
  } else {
    prev_max_distance = false;
  }

  if ( fix.alt.whole > max_height ) {
    prev_max_height == true ? max_height = fix.alt.whole : prev_max_height = true;
  } else {
    prev_max_height = false;
  }

  if ( fix.alt.whole < min_height ) {
    prev_min_height == true ? min_height = fix.alt.whole : prev_min_height = true;
  } else {
    prev_min_height = false;
  }
  
  get_battery();
}
//------------------------------------------------------------------------------------------------
void draw() 
{//  Draws the image to the oled display.
  //  Print the bitmap.
  u8g.drawXBMP( 0, 0, u8g_XMB_width, u8g_XMB_height, u8g_XMB_bits );
  u8g.drawXBMP( battery_lvl, 11, u8g_bat_width, u8g_bat_height, u8g_bat_bits );

  //  Print the data
  u8g.setFont(u8g_font_helvR08);
  //  Number of satellites
  u8g.setPrintPos(0, 8);      u8g.print(fix.satellites);

  //  Max, min speed
  u8g.setPrintPos(37, 8);     u8g.print(max_speed, 1);
  u8g.setPrintPos(65, 8);     u8g.print("kmh");
  u8g.setPrintPos(37, 18);    u8g.print(avg_speed, 1);
  u8g.setPrintPos(65, 18);    u8g.print("kmh");

  //  Distance from home
  u8g.setPrintPos(37, 32);
  if ( max_distance < 9999 )
  {
    u8g.print(max_distance, 1);
    u8g.setPrintPos(76, 32);  u8g.print("m");
  }
  else
  {
    u8g.print(max_distance / 1000, 1);
    u8g.setPrintPos(71, 32);  u8g.print("km");
  }

  //  Max, min, average altitude
  u8g.setPrintPos(97, 8);     u8g.print(max_height);
  u8g.setPrintPos(121, 8);    u8g.print("m");
  u8g.setPrintPos(97, 18);    u8g.print(min_height);
  u8g.setPrintPos(121, 18);   u8g.print("m");
  u8g.setPrintPos(97, 32);    u8g.print(avg_height);
  u8g.setPrintPos(121, 32);   u8g.print("m");
}
//------------------------------------------------------------------------------------------------
void setup() 
{ //  Higher baudrate in order to overcome errors.
  gpsPort.begin( 57600 );
  //  Should set the i2c speed to 400kbit/sec? No idea if it works...
  TWBR = 12;
}
//------------------------------------------------------------------------------------------------
void loop() 
{ //  Check if the Gps is sending data. Parsing takes about 125ms
  while (gps.available( gpsPort )) {
    fix = gps.read();
    //  Do all the calculations in the quiet time, when the GPS isn't sending any data.
    calc_data();
    u8g.firstPage();
    do {
      draw();
    } while ( u8g.nextPage() );
  }
}
//------------------------------------------------------------------------------------------------
//  EOF
//------------------------------------------------------------------------------------------------
